package main

import (
	"fmt"
	"image"
	"image/color"
	"image/draw"
	"log"
	"sort"
	"strings"
	"unsafe"

	"github.com/Tnze/go-mc/data/block"
	"github.com/Tnze/go-mc/level"
	"github.com/Tnze/go-mc/save"
	"github.com/davecgh/go-spew/spew"
	"github.com/go-gl/gl/v4.6-core/gl"
)

type drawOrder struct {
	method   string
	chunk    *save.Chunk
	callback func()
}

var (
	stateTransparency      []uint32
	stateTransparencySSBO  uint32
	terrainHeightmapShader uint32
	drawOrders             chan drawOrder
)

const uint32size = 4
const uint64size = 8

const terrainHeightmapShaderSource = `#version 460
layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;
layout(std430, binding = 3) buffer bterrainTransparency
{
	uint terrainTransparency[];
};
layout(std430, binding = 4) buffer bsectionPalletes
{
	uint sectionPalletes[];
};
layout(std430, binding = 5) buffer bsectionData
{
	uint sectionData[];
};
layout(std430, binding = 6) buffer bout
{
	uint output[];
};
void main() {
	uint sectionPalleteSize = bsectionPalletes[gl_LocalInvocationIndex]
	uint sectionPalleteOffset = bsectionPalletes[gl_WorkGroupSize.z + gl_LocalInvocationIndex]
	
}
` + "\x00"

func drawOrderConsumer() {
	var ssboPalletes uint32
	gl.GenBuffers(1, &ssboPalletes)
	gl.BindBuffer(gl.SHADER_STORAGE_BUFFER, ssboPalletes)
	gl.BindBufferBase(gl.SHADER_STORAGE_BUFFER, 4, ssboPalletes)
	var ssboData uint32
	gl.GenBuffers(1, &ssboData)
	gl.BindBuffer(gl.SHADER_STORAGE_BUFFER, ssboData)
	gl.BindBufferBase(gl.SHADER_STORAGE_BUFFER, 5, ssboData)
	var ssboOut uint32
	outData := make([]uint32, 32*32*16)
	gl.GenBuffers(1, &ssboOut)
	gl.BindBuffer(gl.SHADER_STORAGE_BUFFER, ssboOut)
	gl.BufferData(gl.SHADER_STORAGE_BUFFER, len(outData)*uint32size, gl.Ptr(outData), gl.DYNAMIC_READ)
	gl.BindBufferBase(gl.SHADER_STORAGE_BUFFER, 6, ssboOut)
	gl.BindBuffer(gl.SHADER_STORAGE_BUFFER, 0)
	for dat := range drawOrders {
		switch dat.method {
		case "heightmap":
			gl.UseProgram(terrainHeightmapShader)
		default:
			log.Println("Unknown draw method", dat.method)
		}
		palleteLength := 0
		dataLength := 0
		for _, c := range dat.chunk.Sections {
			palleteLength += len(c.BlockStates.Palette)
			dataLength += len(c.BlockStates.Palette)
		}
		spallete := make([]uint32, 16*2+palleteLength)
		sdata := make([]uint32, 16*2+dataLength)
		for ci, c := range dat.chunk.Sections {
			spallete[ci*2] = uint32(len(c.BlockStates.Palette))
		}
		gl.BindBuffer(gl.SHADER_STORAGE_BUFFER, ssboPalletes)
		gl.BufferData(gl.SHADER_STORAGE_BUFFER, len(palleteData)*uint32size, gl.Ptr(palleteData), gl.DYNAMIC_READ)

		gl.DispatchCompute(16, 16, 16)
		gl.GetNamedBufferSubData(ssboOut, 0, len(outData), gl.Ptr(outData))
		spew.Dump(outData)
	}
}

func app() {
	gl.UseProgram(terrainHeightmapShader)

	var stateTransparencySSBO uint32
	gl.GenBuffers(1, &stateTransparencySSBO)
	gl.BindBuffer(gl.SHADER_STORAGE_BUFFER, stateTransparencySSBO)
	gl.BufferData(gl.SHADER_STORAGE_BUFFER, len(stateTransparency)*uint32size, gl.Ptr(stateTransparency), gl.DYNAMIC_READ)
	gl.BindBufferBase(gl.SHADER_STORAGE_BUFFER, 3, stateTransparencySSBO)
	gl.BindBuffer(gl.SHADER_STORAGE_BUFFER, 0)

	var ssbo1 uint32
	gl.GenBuffers(1, &ssbo1)
	gl.BindBuffer(gl.SHADER_STORAGE_BUFFER, ssbo1)
	gl.BufferData(gl.SHADER_STORAGE_BUFFER, len(numbers2)*uint32size, gl.Ptr(numbers2), gl.DYNAMIC_READ)
	gl.BindBufferBase(gl.SHADER_STORAGE_BUFFER, 4, ssbo1)
	gl.BindBuffer(gl.SHADER_STORAGE_BUFFER, 0)

	gl.DispatchCompute(16, 16, 16)
	gl.GetNamedBufferSubData(ssbo0, 0, len(numbers)*uint32size, gl.Ptr(numbers))
	gl.GetNamedBufferSubData(ssbo1, 0, len(numbers2)*uint32size, gl.Ptr(numbers2))
	fmt.Println("Numbers", numbers)
	fmt.Println("Numbers2", numbers2)
}

func drawChunkAccel(chunk *save.Chunk) (img *image.RGBA) {
	img = image.NewRGBA(image.Rect(0, 0, 16, 16))
	defaultColor := color.RGBA{0, 0, 0, 255}
	draw.Draw(img, img.Bounds(), &image.Uniform{defaultColor}, image.Point{}, draw.Src)
	sort.Slice(chunk.Sections, func(i, j int) bool {
		return chunk.Sections[i].Y > chunk.Sections[j].Y
	})
	for _, s := range chunk.Sections {
		if len(s.BlockStates.Data) == 0 {
			continue
		}
		data := *(*[]uint64)((unsafe.Pointer)(&s.BlockStates.Data))
		palette := s.BlockStates.Palette
		rawPalette := make([]int, len(palette))
		for i, v := range palette {
			rawPalette[i] = int(stateIDs[strings.TrimPrefix(v.Name, "minecraft:")])
		}
		c := level.NewStatesPaletteContainerWithData(16*16*16, data, rawPalette)
		for y := 15; y >= 0; y-- {
			layerImg := image.NewRGBA(image.Rect(0, 0, 16, 16))
			for i := 16*16 - 1; i >= 0; i-- {
				if img.At(i%16, i/16) != defaultColor {
					continue
				}
				state, ok := block.StateID[uint32(c.Get(y*16*16+i))]
				if !ok {
					continue
				}
				block, ok := block.ByID[state]
				if !ok {
					continue
				}
				if !block.Transparent {
					absy := uint8(int(s.Y)*16 + y)
					layerImg.Set(i%16, i/16, color.RGBA{absy, absy, 255, 255})
				}
			}
			draw.Draw(
				img, image.Rect(0, 0, 16, 16),
				layerImg, image.Pt(0, 0),
				draw.Over,
			)
		}
	}
	return img
}

func prepareShaders() (err error) {
	cap := uint32(0)
	for k := range block.StateID {
		if cap < k {
			cap = k
		}
	}
	stateTransparency = make([]uint32, cap/32+1)
	log.Println("stateTransparency is", cap/32+1, "uint32 long")
	log.Println("stateTransparency is", (cap/32+1)*uint32size, "bytes")
	for k, v := range block.StateID {
		block, ok := block.ByID[v]
		if !ok {
			continue
		}
		if block.Transparent {
			stateTransparency[k/32] = stateTransparency[k/32] | (1 << (k % 32))
		}
	}
	terrainHeightmapShader, err = newProgram(terrainHeightmapShaderSource)
	return err
}
